<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport"
    content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="theme-color" content="#2196f3">
  <title>Frango da Mama ‚Äî Rotas</title>
  <link rel="stylesheet" href="lib/framework7-bundle.min.css">
  <link rel="stylesheet" href="css/link2.css">
  <link rel="stylesheet" href="css/materialdesignicons.min.css">
  <link rel="stylesheet" href="css/remixicon.css">

<!-- === Loading overlay (cole no <head> ou logo ap√≥s <body>) === -->
<script>
  // Reutiliz√°vel: usa app.preloader quando existir, sen√£o cria overlay custom
  function showLoading(text) {
    try {
      if (window.app && app.preloader && typeof app.preloader.show === 'function') {
        app.preloader.show();
        return;
      }
    } catch (e) { /* ignore */ }

    if (!document.getElementById('sys-loader')) {
      const ov = document.createElement('div');
      ov.id = 'sys-loader';
      ov.style.position = 'fixed';
      ov.style.left = '0';
      ov.style.top = '0';
      ov.style.right = '0';
      ov.style.bottom = '0';
      ov.style.background = 'rgba(0,0,0,0.45)';
      ov.style.zIndex = 99999;
      ov.style.display = 'flex';
      ov.style.alignItems = 'center';
      ov.style.justifyContent = 'center';
      ov.innerHTML = `<div style="background:#fff;padding:14px 18px;border-radius:10px;display:flex;align-items:center;gap:12px;min-width:180px">
        <div style="width:22px;height:22px;border:3px solid #ddd;border-top-color:#333;border-radius:50%;animation:spin 0.8s linear infinite"></div>
        <div style="font-weight:600;color:#222">${text||'Carregando...'}</div>
      </div>`;
      document.body.appendChild(ov);
      const s = document.createElement('style');
      s.id = 'sys-loader-style';
      s.innerHTML = `@keyframes spin{to{transform:rotate(360deg)}}`;
      document.head.appendChild(s);
    } else {
      const ov = document.getElementById('sys-loader');
      ov.style.display = 'flex';
      const textDiv = ov.querySelector('div > div:last-child');
      if (textDiv) textDiv.textContent = text || 'Carregando...';
    }
  }

  function hideLoading() {
    try {
      if (window.app && app.preloader && typeof app.preloader.hide === 'function') {
        app.preloader.hide();
        return;
      }
    } catch (e) { /* ignore */ }

    const ov = document.getElementById('sys-loader');
    if (ov) ov.style.display = 'none';
  }
</script>


</head>

<body>
  <div id="app">
    <div class="view view-main">
      <!-- Toolbar inferior -->
      <div class="toolbar toolbar-bottom">
        <div class="toolbar-inner display-flex">
          <a href="/loadingindex/" class="tab-link link"><i class="ri-restaurant-line"></i><span>Pedidos</span></a>
          <a href="/loadinglink2/" class="tab-link link active"><i class="ri-map-pin-line"></i><span>Rotas</span></a>
              <a href="/loadinglink3/" class="tab-link link"><i class="ri-wallet-3-line"></i><span>Financeiro</span></a>
          <a href="/loadinglink4/" class="tab-link link"><i class="ri-settings-3-line"></i><span>Configura√ß√µes</span></a>
        </div>
      </div>

      <!-- P√°gina principal -->
      <div data-name="link2" class="page color-theme-blue">
        <div class="navbar">
          <div class="navbar-bg"></div>
          <div class="navbar-inner">
            <div class="title" id="app-title">Rotas de Entregas</div>
          </div>
        </div>

          <div class="page-content">
            <div class="block">
              <!-- Bot√£o com estilo Framework7 -->
              <a href="#" id="btn-carregar" class="button button-fill">Carregar e Agrupar Entregas</a>
            </div>
            <div class="block" id="lista-grupos"></div>
          </div>
        </div>
    </div>

    <!-- Path to Framework7 Library Bundle JS-->
    <script type="text/javascript" src="lib/framework7-bundle.min.js"></script>
	  <!-- jQuery -->
	  <script type="text/javascript" src="lib/jquery-3.7.0.min.js"></script>	
    <script src="js/funcoes.js"></script>
    <!-- Roteamento do app-->
    <script type="text/javascript" src="js/routes.js"></script>
    <script src="cordova.js"></script>

  <script>
    app.ptr.done(); // usa o app j√° existente
  
    // Usar Dom7 (o "jQuery" do Framework7)
    var $$ = Dom7;

    // Evento quando o usu√°rio puxa para atualizar
    $$('.ptr-content').on('ptr:refresh', function (e) {
        // Simula uma requisi√ß√£o de rede ou recarregamento
        setTimeout(function () {
            app.ptr.done(); // Finaliza o preload
        });
    });

    // Evento para qualquer p√°gina inicializada
    $$(document).on('page:init', function (e) {
      const page = e.detail.page;
      console.log(`P√°gina inicializada: ${page.name}`);

      // Procura todos os bot√µes dentro da p√°gina
      $$(page.el).find('a, button').each(function () {
        const btn = $$(this);
        // Adiciona evento de click de debug
        btn.on('click', function () {
          console.log(`Bot√£o clicado na p√°gina "${page.name}":`, btn.text() || btn.attr('id') || 'Sem texto/ID');
        });
      });
    });

    // Tamb√©m adiciona um listener global de click como backup
    document.addEventListener('click', function (e) {
      const el = e.target;
      if (el.tagName === 'BUTTON' || el.tagName === 'A') {
        console.log('Clique detectado globalmente em bot√£o/link:', el.textContent || el.id);
      }
    });

    const SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbxXmiHz07x5Q7zN1kFUPmVE4wUq7FyET_BSZlqGme74-NRvrvAyjQWonpuiK8DVjCmCNA/exec';

    // Fun√ß√£o para carregar pedidos
  // Substitua sua fun√ß√£o carregarPedidos atual por esta
// === Fun√ß√£o carregarPedidos com loading e prote√ß√£o de bot√£o ===
// ----------------- Substitua por este carregarPedidos -----------------
async function carregarPedidos() {
  const container = document.getElementById('lista-grupos');
  const btn = document.getElementById('btn-carregar');
  console.log('[carregarPedidos] iniciado');

  if (btn) {
    btn.classList.add('disabled'); btn.setAttribute('aria-disabled','true'); btn.disabled = true;
    btn.dataset._lastClicked = Date.now();
  }

  // mensagem inicial no UI
  // if (container) container.innerHTML = '<div class="block"><p>Carregando pedidos... (aguarde)</p></div>';

  showLoading('Carregando pedidos...');

  try {
    const now = new Date();
    const saoPauloDate = new Date(now.getTime() - 3 * 60 * 60 * 1000);
    const today = saoPauloDate.toISOString().slice(0, 10);
    const url = `${SCRIPT_URL}?date=${today}&_=${Date.now()}`;

    console.log('[carregarPedidos] fetch ->', url);
    const res = await fetch(url, { cache: 'no-store' });
    console.log('[carregarPedidos] fetch conclu√≠do, status:', res.status, res.statusText);

    const text = await res.text();
    console.log('[carregarPedidos] resposta (raw):', text);

    let data;
    try {
      data = JSON.parse(text);
    } catch (e) {
      console.error('[carregarPedidos] erro ao parsear JSON:', e);
      container.innerHTML = `<div class="block"><p>Resposta inesperada do servidor. Veja console. (parse error)</p></div>`;
      return;
    }

    const pedidos = data.pedidos || [];

// --- after: const pedidos = data.pedidos || []; ---
console.log('[carregarPedidos] pedidos carregados count:', pedidos.length);

// Tente recuperar grupos salvos (GET para seu handler que retorna √∫ltimo salvo)
// Ajuste a URL/param se seu endpoint for diferente (ex: action=getLastGroups)
try {
  console.log('[carregarPedidos] solicitando √∫ltimos grupos salvos...');
  const gRes = await fetch(`${SCRIPT_URL}?action=getLastGroups&_=${Date.now()}`, { cache: 'no-store' });
  console.log('[carregarPedidos] getLastGroups status:', gRes.status);
  const gText = await gRes.text();
  console.log('[carregarPedidos] getLastGroups resposta raw:', gText);

  let gJson = null;
  try { gJson = JSON.parse(gText); } catch(e) { gJson = null; }
  console.log('[carregarPedidos] getLastGroups json:', gJson);

  // Extrai string/array com toler√¢ncia: em seus logs veio {sucesso:true, grupos: '[[...],[]]' }
  let savedGroupsRaw = (gJson && (gJson.grupos || gJson.groups)) || null;
  if (typeof savedGroupsRaw === 'string') {
    try {
      savedGroupsRaw = JSON.parse(savedGroupsRaw);
    } catch (e) {
      console.warn('[carregarPedidos] parse savedGroups string falhou:', e);
    }
  }

if (Array.isArray(savedGroupsRaw)) {
  // mapeia rows salvos para objetos pedidos (ignora rows n√£o encontrados ou entregues)
  const mappedGroups = savedGroupsRaw.map(groupArr => {
    if (!Array.isArray(groupArr)) return [];
    return groupArr.map(rowVal => {
      const rowStr = String(rowVal);
      const found = pedidos.find(p => String(p._sheetRow) === rowStr);
      if (!found) {
        console.warn('[carregarPedidos] pedido n√£o encontrado para row', rowStr);
        return null;
      }
      // IGNORA pedidos j√° entregues
      if (found.entregue === true || String(found.entregue).toLowerCase() === 'true' || String(found.entregue) === '1') {
        console.log('[carregarPedidos] pedido j√° entregue ‚Äî ignorando no grupo salvo:', rowStr);
        return null;
      }
      return found;
    }).filter(Boolean);
  }).filter(g => g.length > 0); // remove grupos vazios

  const totalMapped = mappedGroups.reduce((s, g) => s + g.length, 0);
  console.log('[carregarPedidos] mappedGroups (sem entregues):', mappedGroups, ' totalMapped:', totalMapped);

  // marca os rows j√° inclu√≠dos nos grupos salvos (ap√≥s filtro)
  const included = new Set();
  mappedGroups.forEach(g => g.forEach(p => { if (p && p._sheetRow) included.add(String(p._sheetRow)); }));

  // pedidos que ficaram de fora (novos pedidos ou entregues)
  const remaining = pedidos.filter(p => !included.has(String(p._sheetRow)));
  console.log('[carregarPedidos] remaining pedidos (n√£o estavam nos grupos salvos ou eram entregues):', remaining.map(r=>r._sheetRow));

  // agrupa apenas os remanescentes automaticamente
  let autoGroups = [];
  if (remaining.length > 0) {
    try {
      autoGroups = agruparEntregasMelhorado(remaining);
      console.log('[carregarPedidos] autoGroups gerados para remanescentes:', autoGroups);
    } catch (e) {
      console.warn('[carregarPedidos] erro ao agrupar remanescentes, fallback criar grupos unit√°rios:', e);
      autoGroups = remaining.map(p => [p]);
    }
  }

  const finalGroups = mappedGroups.concat(autoGroups);
  console.log('[carregarPedidos] finalGroups (salvos sem entregues + autom√°ticos):', finalGroups);

  exibirGrupos(finalGroups);
  return;
}

} catch (err) {
  console.warn('[carregarPedidos] erro ao buscar/usar grupos salvos:', err);
  // continua para agrupar automaticamente
}

// Se n√£o usou grupos salvos, agrupa automaticamente
console.log('[carregarPedidos] nenhum grupo salvo encontrado, agrupando automaticamente');
const gruposAutomaticos = agruparEntregasMelhorado(pedidos);
console.log('[carregarPedidos] grupos autom√°ticos:', gruposAutomaticos);
exibirGrupos(gruposAutomaticos);


    console.log('[carregarPedidos] pedidos array length:', pedidos.length, pedidos);

    if (!pedidos.length) {
      container.innerHTML = '<div class="block"><p>Nenhum pedido encontrado para hoje.</p></div>';
      return;
    }

    // monta mapa row -> pedido (√∫til para reconstruir grupos salvos)
    const pedidosMap = {};
    pedidos.forEach(p => { if (p._sheetRow) pedidosMap[String(p._sheetRow)] = p; });
    window.__debug_pedidosMap = pedidosMap;
    console.log('[carregarPedidos] pedidosMap criado, chaves:', Object.keys(pedidosMap).slice(0,20));

    // tenta obter grupos salvos do servidor (se houver)
    let savedGroups = null;
    try {
      console.log('[carregarPedidos] buscando grupos salvos...');
      const gRes = await fetch(`${SCRIPT_URL}?action=getLastGroups&_=${Date.now()}`, { cache: 'no-store' });
      console.log('[carregarPedidos] getLastGroups status:', gRes.status, gRes.statusText);
      if (gRes && gRes.ok) {
        const gJson = await gRes.json();
        console.log('[carregarPedidos] getLastGroups resposta json:', gJson);
        if (gJson && gJson.grupos) savedGroups = gJson.grupos;
      } else {
        console.warn('[carregarPedidos] getLastGroups n√£o retornou ok', gRes && gRes.status);
      }
    } catch (err) {
      console.warn('[carregarPedidos] erro ao buscar getLastGroups:', err);
    }

    if (savedGroups && Array.isArray(savedGroups) && savedGroups.length > 0) {
      console.log('[carregarPedidos] grupos salvos encontrados (raw):', savedGroups);
      const restored = savedGroups.map(groupRows => {
        return groupRows.map(r => pedidosMap[String(r)]).filter(Boolean);
      }).filter(g => g.length > 0);
      console.log('[carregarPedidos] grupos restaurados (ap√≥s map):', restored);
      if (restored.length > 0) {
        exibirGrupos(restored);
        console.log('[carregarPedidos] exibido agrupamento restaurado');
        return;
      } else {
        console.log('[carregarPedidos] nenhum grupo restaurado mapeou para pedidos atuais, caindo para agrupamento autom√°tico');
      }
    } else {
      console.log('[carregarPedidos] nenhum grupo salvo encontrado, agrupando automaticamente');
    }

    // fallback: agrupar automaticamente e exibir
    const grupos = agruparEntregasMelhorado(pedidos);
    console.log('[carregarPedidos] grupos autom√°ticos:', grupos);
    
    exibirGrupos(grupos);

  } catch (err) {
    console.error('[carregarPedidos] erro geral:', err);
    if (container) container.innerHTML = `<div class="block"><p>Erro ao carregar pedidos. Veja console. (${String(err)})</p></div>`;
    try { app.dialog.alert('Erro ao carregar pedidos. Verifique console e Network (DevTools).'); } catch(e){/* ignore */ }
  } finally {
    hideLoading();
    if (btn) { btn.classList.remove('disabled'); btn.removeAttribute('aria-disabled'); btn.disabled = false; }
    console.log('[carregarPedidos] finalizado');
  }
}
// ----------------- fim carregarPedidos -----------------

// --- Ouve evento "pedido:adicionado" e reage recarregando e agrupando ---
window.addEventListener('pedido:adicionado', function (ev) {
  console.log('[link2] evento pedido:adicionado recebido', ev && ev.detail);
  try {
    // chama a fun√ß√£o que carrega pedidos e exibe grupos
    if (typeof carregarPedidos === 'function') {
      carregarPedidos();
    } else {
      console.warn('[link2] carregarPedidos() n√£o dispon√≠vel no momento');
    }
  } catch (err) {
    console.error('[link2] erro ao reagrupar ap√≥s pedido adicionado:', err);
  }
});

// Ao entrar na p√°gina (ou quando a p√°gina de rotas for mostrada), checa o flag sessionStorage
document.addEventListener('visibilitychange', function () {
  if (document.visibilityState === 'visible') {
    try {
      const v = sessionStorage.getItem('rotas:refresh_at');
      if (v) {
        console.log('[link2] sessionStorage rotas:refresh_at detectado => recarregando grupos');
        sessionStorage.removeItem('rotas:refresh_at');
        if (typeof carregarPedidos === 'function') carregarPedidos();
      }
    } catch (err) { console.warn('[link2] erro checando rotas:refresh_at', err); }
  }
});

// Tamb√©m checar logo ao inicializar a p√°gina (caso venha do index)
if (document.readyState === 'complete' || document.readyState === 'interactive') {
  try {
    const v = sessionStorage.getItem('rotas:refresh_at');
    if (v) {
      console.log('[link2] init: rotas:refresh_at detectado => recarregando');
      sessionStorage.removeItem('rotas:refresh_at');
      if (typeof carregarPedidos === 'function') carregarPedidos();
    }
  } catch (err) { /* ignore */ }
} else {
  window.addEventListener('DOMContentLoaded', function () {
    try {
      const v = sessionStorage.getItem('rotas:refresh_at');
      if (v) {
        console.log('[link2] DOMContentLoaded: rotas:refresh_at detectado => recarregando');
        sessionStorage.removeItem('rotas:refresh_at');
        if (typeof carregarPedidos === 'function') carregarPedidos();
      }
    } catch (err) { /* ignore */ }
  });
}



    function agruparEntregasMelhorado(entregas) {
      const parseHorario = (p) => {
        if (!p.horario_entrega) return null;
        const baseDate = new Date();
        const [h, m] = String(p.horario_entrega).split(':').map(Number);
        return new Date(baseDate.getFullYear(), baseDate.getMonth(), baseDate.getDate(), h, m);
      };

      const entregasValidas = entregas
        .filter(e => e.cep && e.horario_entrega && !e.entregue)
        .map(e => ({ ...e, horario: parseHorario(e) }))
        .filter(e => e.horario instanceof Date && !isNaN(e.horario));

      entregasValidas.sort((a, b) => a.horario - b.horario);

      const grupos = [];
      entregasValidas.forEach(entrega => {
        let adicionada = false;
        const horaEntrega = entrega.horario.getTime();
        const cepBase = entrega.cep.substring(0, 5);

        for (const grupo of grupos) {
          if (grupo.length >= 4) continue;

          const horaPrimeiro = grupo[0].horario.getTime();
          const diffMin = Math.abs(horaEntrega - horaPrimeiro) / 60000;
          const cepGrupo = grupo[0].cep.substring(0, 5);

          if (diffMin <= 25 && cepBase === cepGrupo) {
            grupo.push(entrega);
            adicionada = true;
            break;
          }
        }

        if (!adicionada) grupos.push([entrega]);
      });

      return grupos;
    }

    function gerarLinkGoogleMaps(grupo) {
      const cidade = "Ribeir√£o Preto";
      const uf = "SP";
      const waypointsArray = grupo.map(e =>
        `${e.endereco || ""}, ${e.numero || ""}, ${cidade} - ${uf}, ${e.cep || ""}`
      );
      const baseUrl = "https://www.google.com/maps/dir/?api=1";
      let url = `${baseUrl}&origin=My+Location`;
      const destino = waypointsArray.pop();
      url += `&destination=${encodeURIComponent(destino)}`;
      if (waypointsArray.length > 0) {
        const waypoints = waypointsArray.map(w => encodeURIComponent(w)).join('|');
        url += `&waypoints=${waypoints}`;
      }
      url += "&travelmode=driving";
      return url;
    }

    // Substitui a fun√ß√£o antiga
async function marcarComoEntregueByRows(rows) {
  if (!Array.isArray(rows) || rows.length === 0) return;
  try {
    // atualiza em paralelo (mais r√°pido)
    const promises = rows.map(row => {
      const params = new URLSearchParams({
        action: 'updateStatus',
        row: row,
        campo: 'entregue',
        valor: 'true'
      });
      return fetch(`${SCRIPT_URL}?${params.toString()}`);
    });
    const results = await Promise.all(promises);

    // Log de cada resposta (opcional)
    for (const r of results) {
      try { console.log('updateStatus ok', r.status); } catch(e){}
    }

    // Notifica usu√°rio
    app.dialog.alert('Entrega(s) marcada(s) como entregue!');

    // --- Remove do DOM os pedidos entregues (se n√£o j√° removidos) ---
    // procura e remove cards com esses rows
    rows.forEach(r => {
      const card = document.querySelector(`.pedido-card[data-row="${r}"]`);
      if (card) card.remove();
    });

    // --- Atualiza o agrupamento salvo no servidor ---
    // salva o estado atual (chama a fun√ß√£o que voc√™ j√° tem)
    try {
      if (typeof saveGroupsState === 'function') {
        // aguarda para garantir que o servidor recebeu o novo estado
        await saveGroupsState();
        console.log('[marcarComoEntregueByRows] agrupamento salvo ap√≥s marcar entregue');
      } else {
        console.warn('[marcarComoEntregueByRows] saveGroupsState n√£o dispon√≠vel');
      }
    } catch (err) {
      console.warn('[marcarComoEntregueByRows] erro ao salvar agrupamento ap√≥s marcar entregue:', err);
    }

  } catch (err) {
    console.error('Erro ao marcar entregues em lote:', err);
    app.dialog.alert('Erro ao atualizar entregas.');
  }
}

    // Substitua por esta vers√£o
// --- substituir a fun√ß√£o exibirGrupos inteira por esta ---
function exibirGrupos(grupos) {
  console.log('[exibirGrupos] chamado com grupos (length):', Array.isArray(grupos) ? grupos.length : 'n/a', grupos);

  const container = document.getElementById('lista-grupos');
  container.innerHTML = '';

  // map row -> pedido (para consulta r√°pida)
  window.pedidosByRow = {};

  const cores = ['#007bff', '#28a745', '#ffc107', '#17a2b8', '#ff5722', '#6f42c1', '#e83e8c'];

  const toNumber = (v) => { const n = Number((v===undefined||v===null)?0:v); return isNaN(n)?0:n; };
  const isTrue = (v) => { if (v===true||v===1) return true; const s = String(v||'').trim().toLowerCase(); return s==='true'||s==='1'||s==='sim'||s==='yes'; };
  const fmt = (v) => toNumber(v).toLocaleString('pt-BR', { minimumFractionDigits: 2, maximumFractionDigits: 2 });

  // Preencher pedidosByRow
  grupos.forEach(gr => gr.forEach(p => {
    const row = p._sheetRow || '';
    if (row) window.pedidosByRow[row] = p;
  }));

  grupos.forEach((grupo, i) => {
    const bloco = document.createElement('div');
    bloco.className = 'grupo-entregas';
    bloco.style.background = cores[i % cores.length];
    bloco.style.padding = '12px';
    bloco.style.borderRadius = '10px';
    bloco.style.marginBottom = '12px';
    bloco.dataset.grupoIndex = String(i);

    // calcula total do grupo e se todos est√£o pagos
    const grupoTotal = grupo.reduce((s, p) => s + toNumber(p.preco_total ?? p.precoTotal ?? p.preco ?? 0), 0);
    const grupoPago = grupo.every(p => isTrue(p.pago));
    const rotaUrl = gerarLinkGoogleMaps(grupo);

    // cabe√ßalho com elementos identific√°veis para atualiza√ß√£o posterior
    const headerHTML = `
      <div class="grupo-header" style="display:flex; justify-content: space-between; align-items: center;">
        <div>
          <h3 style="margin:0;">üöö Rota ${i + 1} (<span class="grupo-count">${grupo.length}</span> entregas)</h3>
          <div style="font-size:0.9rem; margin-top:6px;">
            <strong>Total da rota:</strong> <span class="rota-total">R$ ${fmt(grupoTotal)}</span> &nbsp;‚Ä¢&nbsp;
            <strong>Pago:</strong> <span class="rota-pago">${grupoPago ? 'Sim' : 'N√£o'}</span>
          </div>
        </div>
        <label class="checkbox-label">
          <input type="checkbox" class="chk-entregue" ${grupo.every(p => isTrue(p.entregue)) ? 'checked' : ''}>
          <span>Entregue</span>
        </label>
      </div>
    `;

    // cria container onde os pedidos ficar√£o e ser√£o "sortable"
    const listId = `grupo-list-${i}`;
    const pedidosHTML = grupo.map(p => {
      const nome = p.nome_cliente || p.nome || 'Cliente sem nome';
      const endereco = p.endereco ? (p.endereco + (p.numero ? ', ' + p.numero : '')) : '-';
      const cep = p.cep || '---';
      const horario = p.horario_entrega || '';
      const qtdFrango = toNumber(p.qntd_frango ?? p.qtd_frango ?? 0);
      const qtdCoxa = toNumber(p.qntd_sobrecoxa ?? p.qtd_sobrecoxa ?? 0);
      const qtdRefri = toNumber(p.qntd_refri ?? p.qtd_refri ?? 0);
      const qtdArroz = toNumber(p.qntd_arroz ?? p.qtd_arroz ?? 0);
      const qtdMandioca = toNumber(p.qntd_mandioca ?? p.qtd_mandioca ?? 0);
      const qtdMaionese = toNumber(p.qntd_maionese ?? p.qtd_maionese ?? 0);
      const qtdFarofa = toNumber(p.qntd_farofa ?? p.qtd_farofa ?? 0);
      const tipoRefri = p.tipo_refrigerante ?? p.tipo_refri ?? p.tipoRefri ?? '';
      const acompanhamentos = p.acompanhamentos || '';
      const preco = toNumber(p.preco_total ?? p.precoTotal ?? p.preco ?? 0);
      const pago = isTrue(p.pago);
      const row = p._sheetRow || '';

      return `
        <div class="pedido-card" data-row="${row}" style="margin-bottom:8px; padding:10px; background: rgba(255,255,255,0.12); border-radius:8px; cursor:grab;">
          <div style="display:flex; justify-content:space-between; align-items:center;">
            <div style="font-weight:600;">${nome}</div>
            <div style="font-size:0.9rem;">   R$ ${fmt(preco)} <br><strong> Hor√°rio: </strong> ${horario}</div>
          </div>
          <div style="font-size:0.9rem; margin-top:6px;">
            <div><strong>Endere√ßo:</strong> ${endereco}</div>
            <div><strong>CEP:</strong> ${cep} &nbsp;</div>
            <div style="margin-top:6px;"><strong>Itens:</strong> ${qtdFrango ? `Frango ${qtdFrango}` : ''} ${qtdCoxa ? `‚Ä¢ Coxa ${qtdCoxa}` : ''} ${qtdArroz ? `‚Ä¢ Arroz ${qtdArroz}` : ''} ${qtdMandioca ? `‚Ä¢ Mandioca ${qtdMandioca}` : ''} ${qtdMaionese ? `‚Ä¢ Maionese ${qtdMaionese}` : ''} ${qtdFarofa ? `‚Ä¢ Farofa ${qtdFarofa}` : ''}</div>
            ${acompanhamentos ? `<div><strong>Acompanhamentos:</strong> ${acompanhamentos}</div>` : ''}
            ${tipoRefri ? `<div><strong>Refrigerantes:</strong> ${tipoRefri}</div>` : ''}
            ${p.observacoes ? `<div style="margin-top:6px;"><strong>Obs:</strong> ${p.observacoes}</div>` : ''}
            <div style="margin-top:6px;"><strong>Pago:</strong> ${pago ? 'Sim' : 'N√£o'}</div>
          </div>
        </div>
      `;
    }).join('');

    bloco.innerHTML = `
      ${headerHTML}
      <div id="${listId}" class="grupo-list" data-grupo-index="${i}" style="margin-top:10px; min-height:40px;">
        ${pedidosHTML}
      </div>
      <div style="margin-top:10px;">
        <a href="${rotaUrl}" target="_blank" class="btn rota-link">üó∫Ô∏è Abrir Rota Otimizada</a>
      </div>
    `;

    container.appendChild(bloco);
  });

  // --- Inicializa Sortable em cada lista (permite mover entre grupos) ---
const listEls = container.querySelectorAll('.grupo-list');
listEls.forEach(listEl => {
  // eslint-disable-next-line no-undef
  new Sortable(listEl, {
    group: 'entregas',
    animation: 150,
    ghostClass: 'sortable-ghost',
    onEnd: function (evt) {
      // Ao terminar o drag, atualiza totais e links das rotas
      updateAllGroupSummariesAndLinks();
      console.log('[Sortable:onEnd] movido', evt.item.dataset.row, 'para grupo', evt.to.dataset.grupoIndex);

      // salva estado dos grupos (debounced interno)
      if (typeof saveGroupsState === 'function') {
        // chama sem await (salva em background), mas com logs
        saveGroupsState().then(() => {
          console.log('[saveGroupsState] salvo com sucesso');
        }).catch(err => {
          console.error('[saveGroupsState] erro ao salvar agrupamento:', err);
        });
      } else {
        console.warn('saveGroupsState n√£o definido');
      }
    }
  });
});


  // Delegado: quando marcar "Entregue" em um grupo, pega linhas atuais daquele grupo do DOM
  container.querySelectorAll('.chk-entregue'); // garante que existam
  container.removeEventListener && container.removeEventListener('change', onGroupEntregueChanged); // s√≥ por seguran√ßa
  container.addEventListener('change', onGroupEntregueChanged);

  // fun√ß√£o local para tratar mudan√ßa de "entregue"
  function onGroupEntregueChanged(e) {
    const target = e.target;
    if (!target.classList.contains('chk-entregue')) return;
    const bloco = target.closest('.grupo-entregas');
    if (!bloco) return;
    const listEl = bloco.querySelector('.grupo-list');
    const rows = getRowsFromListEl(listEl);
    if (target.checked) {
      // marcar todas do grupo como entregues (usa a fun√ß√£o que faz Promise.all)
      marcarComoEntregueByRows(rows);
      // remove do DOM (comportamento anterior)
      bloco.remove();
    } else {
      // Se desmarcou, opcional: voc√™ pode implementar l√≥gica para desfazer na planilha
      console.log('Desmarcou entregue no grupo', bloco.dataset.grupoIndex);
    }
  }

  // atualiza totais e links com base no DOM atual
  function updateAllGroupSummariesAndLinks() {
    const gruposList = container.querySelectorAll('.grupo-entregas');
    gruposList.forEach(grEl => {
      const listEl = grEl.querySelector('.grupo-list');
      const rows = getRowsFromListEl(listEl);
      // recalcula total
      let total = 0;
      let allPaid = true;
      rows.forEach(r => {
        const p = window.pedidosByRow[r];
        if (p) {
          total += toNumber(p.preco_total ?? p.precoTotal ?? p.preco ?? 0);
          if (!isTrue(p.pago)) allPaid = false;
        }
      });
      const rotaTotalEl = grEl.querySelector('.rota-total');
      const rotaPagoEl = grEl.querySelector('.rota-pago');
      const countEl = grEl.querySelector('.grupo-count');
      const rotaLink = grEl.querySelector('.rota-link');

      if (rotaTotalEl) rotaTotalEl.textContent = `R$ ${fmt(total)}`;
      if (rotaPagoEl) rotaPagoEl.textContent = allPaid ? 'Sim' : 'N√£o';
      if (countEl) countEl.textContent = rows.length;

      // atualiza href do link usando pedidos atuais do DOM
      const grupoObjs = rows.map(r => window.pedidosByRow[r]).filter(Boolean);
      if (rotaLink) {
        rotaLink.href = gerarLinkGoogleMaps(grupoObjs);
      }
    });
  }

  // helper: obtem array de rows (strings/nums) de um elemento list (.grupo-list)
  function getRowsFromListEl(listEl) {
    if (!listEl) return [];
    return Array.from(listEl.children).map(ch => ch.dataset.row).filter(r => r);
  }

  // ---------- Salvar estado dos grupos no servidor ----------
/**
 * Coleta os grupos atuais do DOM (por data-row) e envia para o Apps Script.
 * POST JSON: { action: 'saveGroups', groups: [ [row1,row2], [row3,row4], ... ] }
 */
// ----------------- Substitua por este saveGroupsState -----------------
// Substitua sua saveGroupsState atual por esta vers√£o
async function saveGroupsState() {
  try {
    const container = document.getElementById('lista-grupos');
    if (!container) throw new Error('container lista-grupos n√£o encontrado');

    const gruposEls = Array.from(container.querySelectorAll('.grupo-entregas'));
    const groups = gruposEls.map(grEl => {
      const listEl = grEl.querySelector('.grupo-list');
      const rows = Array.from(listEl.children).map(ch => ch.dataset.row).filter(r => r);
      return rows;
    });

    console.log('[saveGroupsState] groups collected:', groups);
    // salva no objeto global para debug/fallback
    window.__debug_savedGroupsPayload = groups;

    showLoading('Salvando agrupamento (form-urlencoded)...');

    // Envia como application/x-www-form-urlencoded (isso evita preflight na maioria dos casos)
    const params = new URLSearchParams();
    params.append('action', 'saveGroups');
    // envia groups como JSON em um campo
    params.append('groupsJson', JSON.stringify(groups));

    console.log('[saveGroupsState] POST form ->', SCRIPT_URL, params.toString().slice(0,200) + (params.toString().length>200 ? '...':'' ));

    const res = await fetch(SCRIPT_URL, {
      method: 'POST',
      headers: {
        // NOTE: n√£o coloque headers customizados al√©m do Content-Type padr√£o
        'Content-Type': 'application/x-www-form-urlencoded;charset=UTF-8'
      },
      body: params.toString(),
      cache: 'no-store'
    });

    console.log('[saveGroupsState] fetch conclu√≠do, status:', res.status, res.statusText);

    let json = null;
    try { json = await res.json(); } catch (e) { console.warn('[saveGroupsState] n√£o consegui parsear JSON da resposta', e); }

    hideLoading();

    if (res.ok && json && (json.sucesso || json.success)) {
      console.log('[saveGroupsState] salvo com sucesso:', json);
      // opcional: toast
      try { if (window.app && app.toast) app.toast.create({ text:'Agrupamento salvo', closeTimeout:1500 }).open(); } catch(e){/*ignore*/ }
      return json;
    } else {
      console.warn('[saveGroupsState] resposta inesperada:', res.status, res.statusText, json);
      // tenta fallback diagn√≥stico abaixo
      throw new Error('Resposta inesperada do servidor ao salvar grupos');
    }

  } catch (err) {
    try { hideLoading(); } catch(e){/*ignore*/ }
    console.error('[saveGroupsState] erro:', err);

    // fallback diagn√≥stico: abre uma URL GET com groupsJson (√∫til para ver a resposta do Apps Script)
    try {
      const payload = window.__debug_savedGroupsPayload || [];
      const encoded = encodeURIComponent(JSON.stringify(payload));
      const fallbackUrl = `${SCRIPT_URL}?action=saveGroups&groupsJson=${encoded}&_=${Date.now()}`;
      console.log('[saveGroupsState] tentando fallback GET em (abrindo nova aba):', fallbackUrl);
      // abre em nova aba para que voc√™ veja a resposta/erros do Apps Script
      window.open(fallbackUrl, '_blank');
    } catch (fbErr) {
      console.error('[saveGroupsState] fallback GET falhou:', fbErr);
    }

    try {
      if (window.app && app.toast) app.toast.create({ text: 'Erro ao salvar agrupamento. Veja console', closeTimeout: 3000 }).open();
      else alert('Erro ao salvar agrupamento. Veja console.');
    } catch(e){ alert('Erro ao salvar agrupamento. Veja console.'); }
    throw err;
  }
}


  // inicializa os valores (caso o usu√°rio n√£o mova nada)
  updateAllGroupSummariesAndLinks();
}



/* === Handler para "Abrir Rota Otimizada": abre nova aba + copia link + notifica === */
(function setupRotaLinkHandlers(){
  const container = document.getElementById('lista-grupos');
  if(!container) return;

  // util: mostra mensagem curta (usa Framework7 toast se dispon√≠vel)
  function showCopiedMessage(text) {
    try {
      if (window.app && app.toast) {
        app.toast.create({ text: text || 'Link copiado para a √°rea de transfer√™ncia!', closeTimeout: 2000 }).open();
        return;
      }
    } catch(e) { /* ignore */ }

    // fallback simples: pequeno overlay no canto inferior direito
    const id = 'clipboard-toast';
    let el = document.getElementById(id);
    if (!el) {
      el = document.createElement('div');
      el.id = id;
      el.style.position = 'fixed';
      el.style.right = '14px';
      el.style.bottom = '20px';
      el.style.background = 'rgba(0,0,0,0.85)';
      el.style.color = '#fff';
      el.style.padding = '10px 14px';
      el.style.borderRadius = '8px';
      el.style.zIndex = 12000;
      el.style.fontSize = '14px';
      el.style.boxShadow = '0 6px 18px rgba(0,0,0,0.3)';
      document.body.appendChild(el);
    }
    el.textContent = text || 'Link copiado para a √°rea de transfer√™ncia!';
    el.style.opacity = '1';
    // remove depois de 3s
    clearTimeout(el._timeout);
    el._timeout = setTimeout(() => {
      el.style.opacity = '0';
      setTimeout(()=>{ try { el.remove(); } catch(e){} }, 300);
    }, 3000);
  }

  // Delega√ß√£o de clique para links de rota
  container.addEventListener('click', async function (ev) {
    const target = ev.target.closest && ev.target.closest('a.rota-link');
    if (!target) return;

    ev.preventDefault(); // vamos abrir + copiar manualmente

    const href = target.getAttribute('href') || target.dataset.href;
    if (!href) {
      console.warn('rota-link sem href/data-href');
      return;
    }

    // Abrir nova aba imediatamente (melhora compatibilidade com bloqueadores)
    try {
      window.open(href, '_blank');
    } catch (e) {
      console.warn('Erro ao abrir nova aba:', e);
    }

    // Tenta copiar para clipboard (navigator.clipboard)
    try {
      if (navigator.clipboard && navigator.clipboard.writeText) {
        await navigator.clipboard.writeText(href);
        showCopiedMessage('Link copiado para a √°rea de transfer√™ncia!');
      } else {
        // fallback: textarea tempor√°rio
        const ta = document.createElement('textarea');
        ta.value = href;
        ta.style.position = 'fixed';
        ta.style.left = '-9999px';
        document.body.appendChild(ta);
        ta.select();
        try { document.execCommand('copy'); showCopiedMessage('Link copiado para a √°rea de transfer√™ncia!'); }
        catch (err) { showCopiedMessage('N√£o foi poss√≠vel copiar automaticamente. Cole manualmente.'); }
        setTimeout(()=>ta.remove(), 50);
      }
    } catch (err) {
      console.warn('Erro ao copiar para clipboard:', err);
      showCopiedMessage('N√£o foi poss√≠vel copiar automaticamente. Link aberto em nova aba.');
    }
  });
})();




  document.getElementById('btn-carregar').addEventListener('click', carregarPedidos);

  // limpa bot√£o/handler antigo caso exista (apenas para seguran√ßa/compatibilidade)
try {
  const oldBtn = document.getElementById('btn-salvar-grupos');
  if (oldBtn) oldBtn.remove();
  if (window.__saveGruposHandler) delete window.__saveGruposHandler;
} catch (e) { console.warn('limpeza botao salvar error', e); }

  </script>

</body>

<!-- SortableJS para drag & drop entre listas -->
<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>

</html>
